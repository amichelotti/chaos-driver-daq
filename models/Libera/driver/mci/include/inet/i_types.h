// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __i__types_hh__
#define __i__types_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_i__types
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_i__types
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_i__types
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE i_NET

_CORBA_MODULE_BEG

  class NotFound : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member what;

  

    inline NotFound() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    NotFound(const NotFound&);
    NotFound(const char* i_what);
    NotFound& operator=(const NotFound&);
    virtual ~NotFound();
    virtual void _raise() const;
    static NotFound* _downcast(::CORBA::Exception*);
    static const NotFound* _downcast(const ::CORBA::Exception*);
    static inline NotFound* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NotFound;

  class InvalidType : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member what;

  

    inline InvalidType() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidType(const InvalidType&);
    InvalidType(const char* i_what);
    InvalidType& operator=(const InvalidType&);
    virtual ~InvalidType();
    virtual void _raise() const;
    static InvalidType* _downcast(::CORBA::Exception*);
    static const InvalidType* _downcast(const ::CORBA::Exception*);
    static inline InvalidType* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidType;

  class ValueException : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member what;

  

    inline ValueException() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ValueException(const ValueException&);
    ValueException(const char* i_what);
    ValueException& operator=(const ValueException&);
    virtual ~ValueException();
    virtual void _raise() const;
    static ValueException* _downcast(::CORBA::Exception*);
    static const ValueException* _downcast(const ::CORBA::Exception*);
    static inline ValueException* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueException;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Flags;

  typedef ::CORBA::ULongLong Flags;
  typedef ::CORBA::ULongLong_out Flags_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NodeName;

  typedef char* NodeName;
  typedef ::CORBA::String_var NodeName_var;
  typedef ::CORBA::String_out NodeName_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NodeNames;

  class NodeNames_var;

  class NodeNames : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef NodeNames_var _var_type;
    inline NodeNames() {}
    inline NodeNames(const NodeNames& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline NodeNames(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline NodeNames(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline NodeNames& operator = (const NodeNames& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class NodeNames_out;

  class NodeNames_var {
  public:
    inline NodeNames_var() : _pd_seq(0) {}
    inline NodeNames_var(NodeNames* _s) : _pd_seq(_s) {}
    inline NodeNames_var(const NodeNames_var& _s) {
      if( _s._pd_seq )  _pd_seq = new NodeNames(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~NodeNames_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline NodeNames_var& operator = (NodeNames* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline NodeNames_var& operator = (const NodeNames_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new NodeNames;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline NodeNames* operator -> () { return _pd_seq; }
    inline const NodeNames* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator NodeNames& () const { return *_pd_seq; }
#else
    inline operator const NodeNames& () const { return *_pd_seq; }
    inline operator NodeNames& () { return *_pd_seq; }
#endif
      
    inline const NodeNames& in() const { return *_pd_seq; }
    inline NodeNames&       inout()    { return *_pd_seq; }
    inline NodeNames*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline NodeNames* _retn() { NodeNames* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class NodeNames_out;
    
  private:
    NodeNames* _pd_seq;
  };

  class NodeNames_out {
  public:
    inline NodeNames_out(NodeNames*& _s) : _data(_s) { _data = 0; }
    inline NodeNames_out(NodeNames_var& _s)
      : _data(_s._pd_seq) { _s = (NodeNames*) 0; }
    inline NodeNames_out(const NodeNames_out& _s) : _data(_s._data) {}
    inline NodeNames_out& operator = (const NodeNames_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline NodeNames_out& operator = (NodeNames* _s) {
      _data = _s;
      return *this;
    }
    inline operator NodeNames*&()  { return _data; }
    inline NodeNames*& ptr()       { return _data; }
    inline NodeNames* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    NodeNames*& _data;

  private:
    NodeNames_out();
    NodeNames_out& operator=(const NodeNames_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NodePath;

  typedef NodeNames NodePath;
  typedef NodeNames_var NodePath_var;
  typedef NodeNames_out NodePath_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringVec;

  class StringVec_var;

  class StringVec : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringVec_var _var_type;
    inline StringVec() {}
    inline StringVec(const StringVec& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringVec(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringVec(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringVec& operator = (const StringVec& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringVec_out;

  class StringVec_var {
  public:
    inline StringVec_var() : _pd_seq(0) {}
    inline StringVec_var(StringVec* _s) : _pd_seq(_s) {}
    inline StringVec_var(const StringVec_var& _s) {
      if( _s._pd_seq )  _pd_seq = new StringVec(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~StringVec_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline StringVec_var& operator = (StringVec* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringVec_var& operator = (const StringVec_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new StringVec;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringVec* operator -> () { return _pd_seq; }
    inline const StringVec* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringVec& () const { return *_pd_seq; }
#else
    inline operator const StringVec& () const { return *_pd_seq; }
    inline operator StringVec& () { return *_pd_seq; }
#endif
      
    inline const StringVec& in() const { return *_pd_seq; }
    inline StringVec&       inout()    { return *_pd_seq; }
    inline StringVec*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringVec* _retn() { StringVec* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringVec_out;
    
  private:
    StringVec* _pd_seq;
  };

  class StringVec_out {
  public:
    inline StringVec_out(StringVec*& _s) : _data(_s) { _data = 0; }
    inline StringVec_out(StringVec_var& _s)
      : _data(_s._pd_seq) { _s = (StringVec*) 0; }
    inline StringVec_out(const StringVec_out& _s) : _data(_s._data) {}
    inline StringVec_out& operator = (const StringVec_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringVec_out& operator = (StringVec* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringVec*&()  { return _data; }
    inline StringVec*& ptr()       { return _data; }
    inline StringVec* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringVec*& _data;

  private:
    StringVec_out();
    StringVec_out& operator=(const StringVec_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Int8Buffer;

  class Int8Buffer_var;

  class Int8Buffer : public _CORBA_Unbounded_Sequence_Char {
  public:
    typedef Int8Buffer_var _var_type;
    inline Int8Buffer() {}
    inline Int8Buffer(const Int8Buffer& _s)
      : _CORBA_Unbounded_Sequence_Char(_s) {}

    inline Int8Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Char(_max) {}
    inline Int8Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Char* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Char(_max, _len, _val, _rel) {}

  

    inline Int8Buffer& operator = (const Int8Buffer& _s) {
      _CORBA_Unbounded_Sequence_Char::operator=(_s);
      return *this;
    }
  };

  class Int8Buffer_out;

  class Int8Buffer_var {
  public:
    inline Int8Buffer_var() : _pd_seq(0) {}
    inline Int8Buffer_var(Int8Buffer* _s) : _pd_seq(_s) {}
    inline Int8Buffer_var(const Int8Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Int8Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Int8Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Int8Buffer_var& operator = (Int8Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Int8Buffer_var& operator = (const Int8Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Int8Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Char& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Int8Buffer* operator -> () { return _pd_seq; }
    inline const Int8Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Int8Buffer& () const { return *_pd_seq; }
#else
    inline operator const Int8Buffer& () const { return *_pd_seq; }
    inline operator Int8Buffer& () { return *_pd_seq; }
#endif
      
    inline const Int8Buffer& in() const { return *_pd_seq; }
    inline Int8Buffer&       inout()    { return *_pd_seq; }
    inline Int8Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Int8Buffer* _retn() { Int8Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Int8Buffer_out;
    
  private:
    Int8Buffer* _pd_seq;
  };

  class Int8Buffer_out {
  public:
    inline Int8Buffer_out(Int8Buffer*& _s) : _data(_s) { _data = 0; }
    inline Int8Buffer_out(Int8Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (Int8Buffer*) 0; }
    inline Int8Buffer_out(const Int8Buffer_out& _s) : _data(_s._data) {}
    inline Int8Buffer_out& operator = (const Int8Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Int8Buffer_out& operator = (Int8Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator Int8Buffer*&()  { return _data; }
    inline Int8Buffer*& ptr()       { return _data; }
    inline Int8Buffer* operator->() { return _data; }

    inline ::CORBA::Char& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Int8Buffer*& _data;

  private:
    Int8Buffer_out();
    Int8Buffer_out& operator=(const Int8Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UInt8Buffer;

  class UInt8Buffer_var;

  class UInt8Buffer : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef UInt8Buffer_var _var_type;
    inline UInt8Buffer() {}
    inline UInt8Buffer(const UInt8Buffer& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline UInt8Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline UInt8Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline UInt8Buffer& operator = (const UInt8Buffer& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class UInt8Buffer_out;

  class UInt8Buffer_var {
  public:
    inline UInt8Buffer_var() : _pd_seq(0) {}
    inline UInt8Buffer_var(UInt8Buffer* _s) : _pd_seq(_s) {}
    inline UInt8Buffer_var(const UInt8Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new UInt8Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~UInt8Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline UInt8Buffer_var& operator = (UInt8Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UInt8Buffer_var& operator = (const UInt8Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new UInt8Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UInt8Buffer* operator -> () { return _pd_seq; }
    inline const UInt8Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UInt8Buffer& () const { return *_pd_seq; }
#else
    inline operator const UInt8Buffer& () const { return *_pd_seq; }
    inline operator UInt8Buffer& () { return *_pd_seq; }
#endif
      
    inline const UInt8Buffer& in() const { return *_pd_seq; }
    inline UInt8Buffer&       inout()    { return *_pd_seq; }
    inline UInt8Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UInt8Buffer* _retn() { UInt8Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UInt8Buffer_out;
    
  private:
    UInt8Buffer* _pd_seq;
  };

  class UInt8Buffer_out {
  public:
    inline UInt8Buffer_out(UInt8Buffer*& _s) : _data(_s) { _data = 0; }
    inline UInt8Buffer_out(UInt8Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (UInt8Buffer*) 0; }
    inline UInt8Buffer_out(const UInt8Buffer_out& _s) : _data(_s._data) {}
    inline UInt8Buffer_out& operator = (const UInt8Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UInt8Buffer_out& operator = (UInt8Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator UInt8Buffer*&()  { return _data; }
    inline UInt8Buffer*& ptr()       { return _data; }
    inline UInt8Buffer* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UInt8Buffer*& _data;

  private:
    UInt8Buffer_out();
    UInt8Buffer_out& operator=(const UInt8Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Int16Buffer;

  class Int16Buffer_var;

  class Int16Buffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 >  {
  public:
    typedef Int16Buffer_var _var_type;
    inline Int16Buffer() {}
    inline Int16Buffer(const Int16Buffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_s) {}

    inline Int16Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max) {}
    inline Int16Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Short* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline Int16Buffer& operator = (const Int16Buffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class Int16Buffer_out;

  class Int16Buffer_var {
  public:
    inline Int16Buffer_var() : _pd_seq(0) {}
    inline Int16Buffer_var(Int16Buffer* _s) : _pd_seq(_s) {}
    inline Int16Buffer_var(const Int16Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Int16Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Int16Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Int16Buffer_var& operator = (Int16Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Int16Buffer_var& operator = (const Int16Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Int16Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Short& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Int16Buffer* operator -> () { return _pd_seq; }
    inline const Int16Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Int16Buffer& () const { return *_pd_seq; }
#else
    inline operator const Int16Buffer& () const { return *_pd_seq; }
    inline operator Int16Buffer& () { return *_pd_seq; }
#endif
      
    inline const Int16Buffer& in() const { return *_pd_seq; }
    inline Int16Buffer&       inout()    { return *_pd_seq; }
    inline Int16Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Int16Buffer* _retn() { Int16Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Int16Buffer_out;
    
  private:
    Int16Buffer* _pd_seq;
  };

  class Int16Buffer_out {
  public:
    inline Int16Buffer_out(Int16Buffer*& _s) : _data(_s) { _data = 0; }
    inline Int16Buffer_out(Int16Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (Int16Buffer*) 0; }
    inline Int16Buffer_out(const Int16Buffer_out& _s) : _data(_s._data) {}
    inline Int16Buffer_out& operator = (const Int16Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Int16Buffer_out& operator = (Int16Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator Int16Buffer*&()  { return _data; }
    inline Int16Buffer*& ptr()       { return _data; }
    inline Int16Buffer* operator->() { return _data; }

    inline ::CORBA::Short& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Int16Buffer*& _data;

  private:
    Int16Buffer_out();
    Int16Buffer_out& operator=(const Int16Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UInt16Buffer;

  class UInt16Buffer_var;

  class UInt16Buffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
  public:
    typedef UInt16Buffer_var _var_type;
    inline UInt16Buffer() {}
    inline UInt16Buffer(const UInt16Buffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

    inline UInt16Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
    inline UInt16Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline UInt16Buffer& operator = (const UInt16Buffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class UInt16Buffer_out;

  class UInt16Buffer_var {
  public:
    inline UInt16Buffer_var() : _pd_seq(0) {}
    inline UInt16Buffer_var(UInt16Buffer* _s) : _pd_seq(_s) {}
    inline UInt16Buffer_var(const UInt16Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new UInt16Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~UInt16Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline UInt16Buffer_var& operator = (UInt16Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UInt16Buffer_var& operator = (const UInt16Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new UInt16Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UInt16Buffer* operator -> () { return _pd_seq; }
    inline const UInt16Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UInt16Buffer& () const { return *_pd_seq; }
#else
    inline operator const UInt16Buffer& () const { return *_pd_seq; }
    inline operator UInt16Buffer& () { return *_pd_seq; }
#endif
      
    inline const UInt16Buffer& in() const { return *_pd_seq; }
    inline UInt16Buffer&       inout()    { return *_pd_seq; }
    inline UInt16Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UInt16Buffer* _retn() { UInt16Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UInt16Buffer_out;
    
  private:
    UInt16Buffer* _pd_seq;
  };

  class UInt16Buffer_out {
  public:
    inline UInt16Buffer_out(UInt16Buffer*& _s) : _data(_s) { _data = 0; }
    inline UInt16Buffer_out(UInt16Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (UInt16Buffer*) 0; }
    inline UInt16Buffer_out(const UInt16Buffer_out& _s) : _data(_s._data) {}
    inline UInt16Buffer_out& operator = (const UInt16Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UInt16Buffer_out& operator = (UInt16Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator UInt16Buffer*&()  { return _data; }
    inline UInt16Buffer*& ptr()       { return _data; }
    inline UInt16Buffer* operator->() { return _data; }

    inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UInt16Buffer*& _data;

  private:
    UInt16Buffer_out();
    UInt16Buffer_out& operator=(const UInt16Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringBuffer;

  class StringBuffer_var;

  class StringBuffer : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringBuffer_var _var_type;
    inline StringBuffer() {}
    inline StringBuffer(const StringBuffer& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringBuffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringBuffer(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringBuffer& operator = (const StringBuffer& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringBuffer_out;

  class StringBuffer_var {
  public:
    inline StringBuffer_var() : _pd_seq(0) {}
    inline StringBuffer_var(StringBuffer* _s) : _pd_seq(_s) {}
    inline StringBuffer_var(const StringBuffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new StringBuffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~StringBuffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline StringBuffer_var& operator = (StringBuffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringBuffer_var& operator = (const StringBuffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new StringBuffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringBuffer* operator -> () { return _pd_seq; }
    inline const StringBuffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringBuffer& () const { return *_pd_seq; }
#else
    inline operator const StringBuffer& () const { return *_pd_seq; }
    inline operator StringBuffer& () { return *_pd_seq; }
#endif
      
    inline const StringBuffer& in() const { return *_pd_seq; }
    inline StringBuffer&       inout()    { return *_pd_seq; }
    inline StringBuffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringBuffer* _retn() { StringBuffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringBuffer_out;
    
  private:
    StringBuffer* _pd_seq;
  };

  class StringBuffer_out {
  public:
    inline StringBuffer_out(StringBuffer*& _s) : _data(_s) { _data = 0; }
    inline StringBuffer_out(StringBuffer_var& _s)
      : _data(_s._pd_seq) { _s = (StringBuffer*) 0; }
    inline StringBuffer_out(const StringBuffer_out& _s) : _data(_s._data) {}
    inline StringBuffer_out& operator = (const StringBuffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringBuffer_out& operator = (StringBuffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringBuffer*&()  { return _data; }
    inline StringBuffer*& ptr()       { return _data; }
    inline StringBuffer* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringBuffer*& _data;

  private:
    StringBuffer_out();
    StringBuffer_out& operator=(const StringBuffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Int32Buffer;

  class Int32Buffer_var;

  class Int32Buffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef Int32Buffer_var _var_type;
    inline Int32Buffer() {}
    inline Int32Buffer(const Int32Buffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline Int32Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline Int32Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline Int32Buffer& operator = (const Int32Buffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class Int32Buffer_out;

  class Int32Buffer_var {
  public:
    inline Int32Buffer_var() : _pd_seq(0) {}
    inline Int32Buffer_var(Int32Buffer* _s) : _pd_seq(_s) {}
    inline Int32Buffer_var(const Int32Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Int32Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Int32Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Int32Buffer_var& operator = (Int32Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Int32Buffer_var& operator = (const Int32Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Int32Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Int32Buffer* operator -> () { return _pd_seq; }
    inline const Int32Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Int32Buffer& () const { return *_pd_seq; }
#else
    inline operator const Int32Buffer& () const { return *_pd_seq; }
    inline operator Int32Buffer& () { return *_pd_seq; }
#endif
      
    inline const Int32Buffer& in() const { return *_pd_seq; }
    inline Int32Buffer&       inout()    { return *_pd_seq; }
    inline Int32Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Int32Buffer* _retn() { Int32Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Int32Buffer_out;
    
  private:
    Int32Buffer* _pd_seq;
  };

  class Int32Buffer_out {
  public:
    inline Int32Buffer_out(Int32Buffer*& _s) : _data(_s) { _data = 0; }
    inline Int32Buffer_out(Int32Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (Int32Buffer*) 0; }
    inline Int32Buffer_out(const Int32Buffer_out& _s) : _data(_s._data) {}
    inline Int32Buffer_out& operator = (const Int32Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Int32Buffer_out& operator = (Int32Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator Int32Buffer*&()  { return _data; }
    inline Int32Buffer*& ptr()       { return _data; }
    inline Int32Buffer* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Int32Buffer*& _data;

  private:
    Int32Buffer_out();
    Int32Buffer_out& operator=(const Int32Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UInt32Buffer;

  class UInt32Buffer_var;

  class UInt32Buffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 >  {
  public:
    typedef UInt32Buffer_var _var_type;
    inline UInt32Buffer() {}
    inline UInt32Buffer(const UInt32Buffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_s) {}

    inline UInt32Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max) {}
    inline UInt32Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline UInt32Buffer& operator = (const UInt32Buffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class UInt32Buffer_out;

  class UInt32Buffer_var {
  public:
    inline UInt32Buffer_var() : _pd_seq(0) {}
    inline UInt32Buffer_var(UInt32Buffer* _s) : _pd_seq(_s) {}
    inline UInt32Buffer_var(const UInt32Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new UInt32Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~UInt32Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline UInt32Buffer_var& operator = (UInt32Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UInt32Buffer_var& operator = (const UInt32Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new UInt32Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::ULong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UInt32Buffer* operator -> () { return _pd_seq; }
    inline const UInt32Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UInt32Buffer& () const { return *_pd_seq; }
#else
    inline operator const UInt32Buffer& () const { return *_pd_seq; }
    inline operator UInt32Buffer& () { return *_pd_seq; }
#endif
      
    inline const UInt32Buffer& in() const { return *_pd_seq; }
    inline UInt32Buffer&       inout()    { return *_pd_seq; }
    inline UInt32Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UInt32Buffer* _retn() { UInt32Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UInt32Buffer_out;
    
  private:
    UInt32Buffer* _pd_seq;
  };

  class UInt32Buffer_out {
  public:
    inline UInt32Buffer_out(UInt32Buffer*& _s) : _data(_s) { _data = 0; }
    inline UInt32Buffer_out(UInt32Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (UInt32Buffer*) 0; }
    inline UInt32Buffer_out(const UInt32Buffer_out& _s) : _data(_s._data) {}
    inline UInt32Buffer_out& operator = (const UInt32Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UInt32Buffer_out& operator = (UInt32Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator UInt32Buffer*&()  { return _data; }
    inline UInt32Buffer*& ptr()       { return _data; }
    inline UInt32Buffer* operator->() { return _data; }

    inline ::CORBA::ULong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UInt32Buffer*& _data;

  private:
    UInt32Buffer_out();
    UInt32Buffer_out& operator=(const UInt32Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Int64Buffer;

  class Int64Buffer_var;

  class Int64Buffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 >  {
  public:
    typedef Int64Buffer_var _var_type;
    inline Int64Buffer() {}
    inline Int64Buffer(const Int64Buffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_s) {}

    inline Int64Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max) {}
    inline Int64Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::LongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline Int64Buffer& operator = (const Int64Buffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class Int64Buffer_out;

  class Int64Buffer_var {
  public:
    inline Int64Buffer_var() : _pd_seq(0) {}
    inline Int64Buffer_var(Int64Buffer* _s) : _pd_seq(_s) {}
    inline Int64Buffer_var(const Int64Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Int64Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Int64Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Int64Buffer_var& operator = (Int64Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Int64Buffer_var& operator = (const Int64Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Int64Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::LongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Int64Buffer* operator -> () { return _pd_seq; }
    inline const Int64Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Int64Buffer& () const { return *_pd_seq; }
#else
    inline operator const Int64Buffer& () const { return *_pd_seq; }
    inline operator Int64Buffer& () { return *_pd_seq; }
#endif
      
    inline const Int64Buffer& in() const { return *_pd_seq; }
    inline Int64Buffer&       inout()    { return *_pd_seq; }
    inline Int64Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Int64Buffer* _retn() { Int64Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Int64Buffer_out;
    
  private:
    Int64Buffer* _pd_seq;
  };

  class Int64Buffer_out {
  public:
    inline Int64Buffer_out(Int64Buffer*& _s) : _data(_s) { _data = 0; }
    inline Int64Buffer_out(Int64Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (Int64Buffer*) 0; }
    inline Int64Buffer_out(const Int64Buffer_out& _s) : _data(_s._data) {}
    inline Int64Buffer_out& operator = (const Int64Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Int64Buffer_out& operator = (Int64Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator Int64Buffer*&()  { return _data; }
    inline Int64Buffer*& ptr()       { return _data; }
    inline Int64Buffer* operator->() { return _data; }

    inline ::CORBA::LongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Int64Buffer*& _data;

  private:
    Int64Buffer_out();
    Int64Buffer_out& operator=(const Int64Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UInt64Buffer;

  class UInt64Buffer_var;

  class UInt64Buffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 >  {
  public:
    typedef UInt64Buffer_var _var_type;
    inline UInt64Buffer() {}
    inline UInt64Buffer(const UInt64Buffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_s) {}

    inline UInt64Buffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max) {}
    inline UInt64Buffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline UInt64Buffer& operator = (const UInt64Buffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class UInt64Buffer_out;

  class UInt64Buffer_var {
  public:
    inline UInt64Buffer_var() : _pd_seq(0) {}
    inline UInt64Buffer_var(UInt64Buffer* _s) : _pd_seq(_s) {}
    inline UInt64Buffer_var(const UInt64Buffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new UInt64Buffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~UInt64Buffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline UInt64Buffer_var& operator = (UInt64Buffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UInt64Buffer_var& operator = (const UInt64Buffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new UInt64Buffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UInt64Buffer* operator -> () { return _pd_seq; }
    inline const UInt64Buffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UInt64Buffer& () const { return *_pd_seq; }
#else
    inline operator const UInt64Buffer& () const { return *_pd_seq; }
    inline operator UInt64Buffer& () { return *_pd_seq; }
#endif
      
    inline const UInt64Buffer& in() const { return *_pd_seq; }
    inline UInt64Buffer&       inout()    { return *_pd_seq; }
    inline UInt64Buffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UInt64Buffer* _retn() { UInt64Buffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UInt64Buffer_out;
    
  private:
    UInt64Buffer* _pd_seq;
  };

  class UInt64Buffer_out {
  public:
    inline UInt64Buffer_out(UInt64Buffer*& _s) : _data(_s) { _data = 0; }
    inline UInt64Buffer_out(UInt64Buffer_var& _s)
      : _data(_s._pd_seq) { _s = (UInt64Buffer*) 0; }
    inline UInt64Buffer_out(const UInt64Buffer_out& _s) : _data(_s._data) {}
    inline UInt64Buffer_out& operator = (const UInt64Buffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UInt64Buffer_out& operator = (UInt64Buffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator UInt64Buffer*&()  { return _data; }
    inline UInt64Buffer*& ptr()       { return _data; }
    inline UInt64Buffer* operator->() { return _data; }

    inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UInt64Buffer*& _data;

  private:
    UInt64Buffer_out();
    UInt64Buffer_out& operator=(const UInt64Buffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FloatBuffer;

  class FloatBuffer_var;

  class FloatBuffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  {
  public:
    typedef FloatBuffer_var _var_type;
    inline FloatBuffer() {}
    inline FloatBuffer(const FloatBuffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_s) {}

    inline FloatBuffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max) {}
    inline FloatBuffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Float* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline FloatBuffer& operator = (const FloatBuffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class FloatBuffer_out;

  class FloatBuffer_var {
  public:
    inline FloatBuffer_var() : _pd_seq(0) {}
    inline FloatBuffer_var(FloatBuffer* _s) : _pd_seq(_s) {}
    inline FloatBuffer_var(const FloatBuffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new FloatBuffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~FloatBuffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline FloatBuffer_var& operator = (FloatBuffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FloatBuffer_var& operator = (const FloatBuffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new FloatBuffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Float& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FloatBuffer* operator -> () { return _pd_seq; }
    inline const FloatBuffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FloatBuffer& () const { return *_pd_seq; }
#else
    inline operator const FloatBuffer& () const { return *_pd_seq; }
    inline operator FloatBuffer& () { return *_pd_seq; }
#endif
      
    inline const FloatBuffer& in() const { return *_pd_seq; }
    inline FloatBuffer&       inout()    { return *_pd_seq; }
    inline FloatBuffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FloatBuffer* _retn() { FloatBuffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FloatBuffer_out;
    
  private:
    FloatBuffer* _pd_seq;
  };

  class FloatBuffer_out {
  public:
    inline FloatBuffer_out(FloatBuffer*& _s) : _data(_s) { _data = 0; }
    inline FloatBuffer_out(FloatBuffer_var& _s)
      : _data(_s._pd_seq) { _s = (FloatBuffer*) 0; }
    inline FloatBuffer_out(const FloatBuffer_out& _s) : _data(_s._data) {}
    inline FloatBuffer_out& operator = (const FloatBuffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FloatBuffer_out& operator = (FloatBuffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator FloatBuffer*&()  { return _data; }
    inline FloatBuffer*& ptr()       { return _data; }
    inline FloatBuffer* operator->() { return _data; }

    inline ::CORBA::Float& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FloatBuffer*& _data;

  private:
    FloatBuffer_out();
    FloatBuffer_out& operator=(const FloatBuffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DoubleBuffer;

  class DoubleBuffer_var;

  class DoubleBuffer : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef DoubleBuffer_var _var_type;
    inline DoubleBuffer() {}
    inline DoubleBuffer(const DoubleBuffer& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline DoubleBuffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline DoubleBuffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline DoubleBuffer& operator = (const DoubleBuffer& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DoubleBuffer_out;

  class DoubleBuffer_var {
  public:
    inline DoubleBuffer_var() : _pd_seq(0) {}
    inline DoubleBuffer_var(DoubleBuffer* _s) : _pd_seq(_s) {}
    inline DoubleBuffer_var(const DoubleBuffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DoubleBuffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DoubleBuffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DoubleBuffer_var& operator = (DoubleBuffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DoubleBuffer_var& operator = (const DoubleBuffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DoubleBuffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DoubleBuffer* operator -> () { return _pd_seq; }
    inline const DoubleBuffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DoubleBuffer& () const { return *_pd_seq; }
#else
    inline operator const DoubleBuffer& () const { return *_pd_seq; }
    inline operator DoubleBuffer& () { return *_pd_seq; }
#endif
      
    inline const DoubleBuffer& in() const { return *_pd_seq; }
    inline DoubleBuffer&       inout()    { return *_pd_seq; }
    inline DoubleBuffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DoubleBuffer* _retn() { DoubleBuffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DoubleBuffer_out;
    
  private:
    DoubleBuffer* _pd_seq;
  };

  class DoubleBuffer_out {
  public:
    inline DoubleBuffer_out(DoubleBuffer*& _s) : _data(_s) { _data = 0; }
    inline DoubleBuffer_out(DoubleBuffer_var& _s)
      : _data(_s._pd_seq) { _s = (DoubleBuffer*) 0; }
    inline DoubleBuffer_out(const DoubleBuffer_out& _s) : _data(_s._data) {}
    inline DoubleBuffer_out& operator = (const DoubleBuffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DoubleBuffer_out& operator = (DoubleBuffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator DoubleBuffer*&()  { return _data; }
    inline DoubleBuffer*& ptr()       { return _data; }
    inline DoubleBuffer* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DoubleBuffer*& _data;

  private:
    DoubleBuffer_out();
    DoubleBuffer_out& operator=(const DoubleBuffer_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BooleanBuffer;

  class BooleanBuffer_var;

  class BooleanBuffer : public _CORBA_Unbounded_Sequence_Boolean {
  public:
    typedef BooleanBuffer_var _var_type;
    inline BooleanBuffer() {}
    inline BooleanBuffer(const BooleanBuffer& _s)
      : _CORBA_Unbounded_Sequence_Boolean(_s) {}

    inline BooleanBuffer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Boolean(_max) {}
    inline BooleanBuffer(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Boolean* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Boolean(_max, _len, _val, _rel) {}

  

    inline BooleanBuffer& operator = (const BooleanBuffer& _s) {
      _CORBA_Unbounded_Sequence_Boolean::operator=(_s);
      return *this;
    }
  };

  class BooleanBuffer_out;

  class BooleanBuffer_var {
  public:
    inline BooleanBuffer_var() : _pd_seq(0) {}
    inline BooleanBuffer_var(BooleanBuffer* _s) : _pd_seq(_s) {}
    inline BooleanBuffer_var(const BooleanBuffer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new BooleanBuffer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~BooleanBuffer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline BooleanBuffer_var& operator = (BooleanBuffer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline BooleanBuffer_var& operator = (const BooleanBuffer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new BooleanBuffer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline BooleanBuffer* operator -> () { return _pd_seq; }
    inline const BooleanBuffer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator BooleanBuffer& () const { return *_pd_seq; }
#else
    inline operator const BooleanBuffer& () const { return *_pd_seq; }
    inline operator BooleanBuffer& () { return *_pd_seq; }
#endif
      
    inline const BooleanBuffer& in() const { return *_pd_seq; }
    inline BooleanBuffer&       inout()    { return *_pd_seq; }
    inline BooleanBuffer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline BooleanBuffer* _retn() { BooleanBuffer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class BooleanBuffer_out;
    
  private:
    BooleanBuffer* _pd_seq;
  };

  class BooleanBuffer_out {
  public:
    inline BooleanBuffer_out(BooleanBuffer*& _s) : _data(_s) { _data = 0; }
    inline BooleanBuffer_out(BooleanBuffer_var& _s)
      : _data(_s._pd_seq) { _s = (BooleanBuffer*) 0; }
    inline BooleanBuffer_out(const BooleanBuffer_out& _s) : _data(_s._data) {}
    inline BooleanBuffer_out& operator = (const BooleanBuffer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline BooleanBuffer_out& operator = (BooleanBuffer* _s) {
      _data = _s;
      return *this;
    }
    inline operator BooleanBuffer*&()  { return _data; }
    inline BooleanBuffer*& ptr()       { return _data; }
    inline BooleanBuffer* operator->() { return _data; }

    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    BooleanBuffer*& _data;

  private:
    BooleanBuffer_out();
    BooleanBuffer_out& operator=(const BooleanBuffer_var&);
  };

  struct SignalStatItem {
    typedef _CORBA_ConstrType_Variable_Var<SignalStatItem> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::ULongLong total;

    ::CORBA::ULongLong rejected;

    ::CORBA::ULong asize;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef SignalStatItem::_var_type SignalStatItem_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< SignalStatItem,SignalStatItem_var > SignalStatItem_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SignalStatItem;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SignalStats;

  class SignalStats_var;

  class SignalStats : public _CORBA_Unbounded_Sequence< SignalStatItem >  {
  public:
    typedef SignalStats_var _var_type;
    inline SignalStats() {}
    inline SignalStats(const SignalStats& _s)
      : _CORBA_Unbounded_Sequence< SignalStatItem > (_s) {}

    inline SignalStats(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< SignalStatItem > (_max) {}
    inline SignalStats(_CORBA_ULong _max, _CORBA_ULong _len, SignalStatItem* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< SignalStatItem > (_max, _len, _val, _rel) {}

  

    inline SignalStats& operator = (const SignalStats& _s) {
      _CORBA_Unbounded_Sequence< SignalStatItem > ::operator=(_s);
      return *this;
    }
  };

  class SignalStats_out;

  class SignalStats_var {
  public:
    inline SignalStats_var() : _pd_seq(0) {}
    inline SignalStats_var(SignalStats* _s) : _pd_seq(_s) {}
    inline SignalStats_var(const SignalStats_var& _s) {
      if( _s._pd_seq )  _pd_seq = new SignalStats(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~SignalStats_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline SignalStats_var& operator = (SignalStats* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline SignalStats_var& operator = (const SignalStats_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new SignalStats;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline SignalStatItem& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline SignalStats* operator -> () { return _pd_seq; }
    inline const SignalStats* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator SignalStats& () const { return *_pd_seq; }
#else
    inline operator const SignalStats& () const { return *_pd_seq; }
    inline operator SignalStats& () { return *_pd_seq; }
#endif
      
    inline const SignalStats& in() const { return *_pd_seq; }
    inline SignalStats&       inout()    { return *_pd_seq; }
    inline SignalStats*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline SignalStats* _retn() { SignalStats* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class SignalStats_out;
    
  private:
    SignalStats* _pd_seq;
  };

  class SignalStats_out {
  public:
    inline SignalStats_out(SignalStats*& _s) : _data(_s) { _data = 0; }
    inline SignalStats_out(SignalStats_var& _s)
      : _data(_s._pd_seq) { _s = (SignalStats*) 0; }
    inline SignalStats_out(const SignalStats_out& _s) : _data(_s._data) {}
    inline SignalStats_out& operator = (const SignalStats_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline SignalStats_out& operator = (SignalStats* _s) {
      _data = _s;
      return *this;
    }
    inline operator SignalStats*&()  { return _data; }
    inline SignalStats*& ptr()       { return _data; }
    inline SignalStats* operator->() { return _data; }

    inline SignalStatItem& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    SignalStats*& _data;

  private:
    SignalStats_out();
    SignalStats_out& operator=(const SignalStats_var&);
  };

  struct SignalMetaPair {
    typedef _CORBA_ConstrType_Fix_Var<SignalMetaPair> _var_type;

    
    ::CORBA::ULong id;

    ::CORBA::LongLong value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef SignalMetaPair::_var_type SignalMetaPair_var;

  typedef SignalMetaPair& SignalMetaPair_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SignalMetaPair;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SignalMeta;

  class SignalMeta_var;

  class SignalMeta : public _CORBA_Unbounded_Sequence< SignalMetaPair >  {
  public:
    typedef SignalMeta_var _var_type;
    inline SignalMeta() {}
    inline SignalMeta(const SignalMeta& _s)
      : _CORBA_Unbounded_Sequence< SignalMetaPair > (_s) {}

    inline SignalMeta(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< SignalMetaPair > (_max) {}
    inline SignalMeta(_CORBA_ULong _max, _CORBA_ULong _len, SignalMetaPair* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< SignalMetaPair > (_max, _len, _val, _rel) {}

  

    inline SignalMeta& operator = (const SignalMeta& _s) {
      _CORBA_Unbounded_Sequence< SignalMetaPair > ::operator=(_s);
      return *this;
    }
  };

  class SignalMeta_out;

  class SignalMeta_var {
  public:
    inline SignalMeta_var() : _pd_seq(0) {}
    inline SignalMeta_var(SignalMeta* _s) : _pd_seq(_s) {}
    inline SignalMeta_var(const SignalMeta_var& _s) {
      if( _s._pd_seq )  _pd_seq = new SignalMeta(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~SignalMeta_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline SignalMeta_var& operator = (SignalMeta* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline SignalMeta_var& operator = (const SignalMeta_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new SignalMeta;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline SignalMetaPair& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline SignalMeta* operator -> () { return _pd_seq; }
    inline const SignalMeta* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator SignalMeta& () const { return *_pd_seq; }
#else
    inline operator const SignalMeta& () const { return *_pd_seq; }
    inline operator SignalMeta& () { return *_pd_seq; }
#endif
      
    inline const SignalMeta& in() const { return *_pd_seq; }
    inline SignalMeta&       inout()    { return *_pd_seq; }
    inline SignalMeta*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline SignalMeta* _retn() { SignalMeta* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class SignalMeta_out;
    
  private:
    SignalMeta* _pd_seq;
  };

  class SignalMeta_out {
  public:
    inline SignalMeta_out(SignalMeta*& _s) : _data(_s) { _data = 0; }
    inline SignalMeta_out(SignalMeta_var& _s)
      : _data(_s._pd_seq) { _s = (SignalMeta*) 0; }
    inline SignalMeta_out(const SignalMeta_out& _s) : _data(_s._data) {}
    inline SignalMeta_out& operator = (const SignalMeta_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline SignalMeta_out& operator = (SignalMeta* _s) {
      _data = _s;
      return *this;
    }
    inline operator SignalMeta*&()  { return _data; }
    inline SignalMeta*& ptr()       { return _data; }
    inline SignalMeta* operator->() { return _data; }

    inline SignalMetaPair& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    SignalMeta*& _data;

  private:
    SignalMeta_out();
    SignalMeta_out& operator=(const SignalMeta_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_i_NET
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_i_NET
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const i_NET::NotFound& _s);
void operator<<=(::CORBA::Any& _a, const i_NET::NotFound* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::NotFound*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::InvalidType& _s);
void operator<<=(::CORBA::Any& _a, const i_NET::InvalidType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::InvalidType*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::ValueException& _s);
void operator<<=(::CORBA::Any& _a, const i_NET::ValueException* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::ValueException*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::NodeNames& _s);
void operator<<=(::CORBA::Any& _a, i_NET::NodeNames* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::NodeNames*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::NodeNames*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::StringVec& _s);
void operator<<=(::CORBA::Any& _a, i_NET::StringVec* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::StringVec*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::StringVec*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::Int8Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::Int8Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::Int8Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::Int8Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::UInt8Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::UInt8Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::UInt8Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::UInt8Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::Int16Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::Int16Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::Int16Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::Int16Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::UInt16Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::UInt16Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::UInt16Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::UInt16Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::StringBuffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::StringBuffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::StringBuffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::StringBuffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::Int32Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::Int32Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::Int32Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::Int32Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::UInt32Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::UInt32Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::UInt32Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::UInt32Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::Int64Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::Int64Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::Int64Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::Int64Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::UInt64Buffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::UInt64Buffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::UInt64Buffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::UInt64Buffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::FloatBuffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::FloatBuffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::FloatBuffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::FloatBuffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::DoubleBuffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::DoubleBuffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::DoubleBuffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::DoubleBuffer*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::BooleanBuffer& _s);
void operator<<=(::CORBA::Any& _a, i_NET::BooleanBuffer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::BooleanBuffer*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::BooleanBuffer*& _sp);

extern void operator<<=(::CORBA::Any& _a, const i_NET::SignalStatItem& _s);
extern void operator<<=(::CORBA::Any& _a, i_NET::SignalStatItem* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::SignalStatItem*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::SignalStatItem*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::SignalStats& _s);
void operator<<=(::CORBA::Any& _a, i_NET::SignalStats* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::SignalStats*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::SignalStats*& _sp);

extern void operator<<=(::CORBA::Any& _a, const i_NET::SignalMetaPair& _s);
extern void operator<<=(::CORBA::Any& _a, i_NET::SignalMetaPair* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::SignalMetaPair*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::SignalMetaPair*& _sp);

void operator<<=(::CORBA::Any& _a, const i_NET::SignalMeta& _s);
void operator<<=(::CORBA::Any& _a, i_NET::SignalMeta* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, i_NET::SignalMeta*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const i_NET::SignalMeta*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_i__types
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_i__types
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_i__types
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_i__types
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_i__types
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_i__types
#endif

#endif  // __i__types_hh__

